<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>US State Metrics Map</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    .title {
      margin: 20px 0;
      font-size: 24px;
      font-weight: bold;
    }

    .map-container {
      background-color: rgb(248, 209, 226);
      padding: 20px;
      position: relative;
      display: inline-block;
      border-radius: 10px;
    }

    select {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 16px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #ffffff;
      z-index: 10;
    }

    svg {
      display: block;
    }

    .tooltip {
      position: absolute;
      background-color: white;
      border: 1px solid #ccc;
      padding: 5px;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div class="title">US State Metrics Visualization</div>

  <div class="map-container">
    <select id="metric">
      <option value="personalIncome">Personal Income</option>
      <option value="gdp">GDP</option>
      <option value="consumerSpending">Consumer Spending</option>
    </select>
    <svg width="960" height="600"></svg>
    <div id="legend"></div>
  </div>

  <div class="tooltip" style="display: none;"></div>

  <script>
    const width = 960, height = 600;
    const svg = d3.select("svg");
    const tooltip = d3.select(".tooltip");

    const projection = d3.geoAlbersUsa().scale(1000).translate([width / 2, height / 2]);
    const path = d3.geoPath().projection(projection);

    const stateIdToName = {
      1: "Alabama",
      2: "Alaska",
      4: "Arizona",
      5: "Arkansas",
      6: "California",
      8: "Colorado",
      9: "Connecticut",
      10: "Delaware",
      11: "District of Columbia",
      12: "Florida",
      13: "Georgia",
      15: "Hawaii",
      16: "Idaho",
      17: "Illinois",
      18: "Indiana",
      19: "Iowa",
      20: "Kansas",
      21: "Kentucky",
      22: "Louisiana",
      23: "Maine",
      24: "Maryland",
      25: "Massachusetts",
      26: "Michigan",
      27: "Minnesota",
      28: "Mississippi",
      29: "Missouri",
      30: "Montana",
      31: "Nebraska",
      32: "Nevada",
      33: "New Hampshire",
      34: "New Jersey",
      35: "New Mexico",
      36: "New York",
      37: "North Carolina",
      38: "North Dakota",
      39: "Ohio",
      40: "Oklahoma",
      41: "Oregon",
      42: "Pennsylvania",
      44: "Rhode Island",
      45: "South Carolina",
      46: "South Dakota",
      47: "Tennessee",
      48: "Texas",
      49: "Utah",
      50: "Vermont",
      51: "Virginia",
      53: "Washington",
      54: "West Virginia",
      55: "Wisconsin",
      56: "Wyoming"
    };

    const metricLabels = {
      personalIncome: "Personal Income",
      gdp: "GDP",
      consumerSpending: "Consumer Spending"
    };

    const metricUnits = {
      personalIncome: "USD",
      gdp: "Billion USD",
      consumerSpending: "USD"
    };

    d3.json("data/cleaned-us-state-boundaries.json").then(geoData => {
      d3.csv("data/cleaned-personal-income.csv").then(personalIncome => {
        d3.csv("data/cleaned-gdp.csv").then(gdp => {
          d3.csv("data/cleaned-consumer-spending.csv").then(consumerSpending => {
            const states = topojson.feature(geoData, geoData.objects.states);

            const data = {};
            personalIncome.forEach(d => {
              data[d.GeoName] = { personalIncome: +d["2023"] };
            });

            gdp.forEach(d => {
              if (!data[d.GeoName]) data[d.GeoName] = {};
              data[d.GeoName].gdp = +d["2023"];
            });

            consumerSpending.forEach(d => {
              if (!data[d.GeoName]) data[d.GeoName] = {};
              data[d.GeoName].consumerSpending = +d["2023"];
            });

            const colorScale = d3.scaleQuantize().range(d3.schemeBlues[9]);

            const updateMap = (metric) => {
              const values = states.features.map(d => {
                const stateName = stateIdToName[d.id];
                return data[stateName]?.[metric] || 0;
              });

              colorScale.domain([d3.min(values), d3.max(values)]);

              updateLegend(colorScale, metric);

              svg.selectAll("path")
                .data(states.features)
                .join("path")
                .attr("d", path)
                .attr("fill", d => {
                  const stateName = stateIdToName[d.id];
                  const value = data[stateName]?.[metric];
                  return value ? colorScale(value) : "#ccc";
                })
                .attr("stroke", "#000")
                .attr("stroke-width", 0.5)
                .on("mouseover", (event, d) => {
                  const stateName = stateIdToName[d.id];
                  const stateData = data[stateName];
                  const metricValue = stateData ? stateData[metric] : "N/A";
                  const unit = metricUnits[metric] ? ` ${metricUnits[metric]}` : "";

                  const container = document.querySelector(".map-container");
                  const rect = container.getBoundingClientRect();

                  tooltip.style("display", "block")
                    .html(`
      <strong>${stateName}</strong><br>
      ${metricLabels[metric]}: ${metricValue}${unit}
    `)
                    .style("left", `${rect.right - tooltip.node().offsetWidth - 10}px`)
                    .style("top", `${rect.top + 10}px`);
                  d3.select(event.currentTarget).attr("fill", "#db4780");
                })
                .on("mouseout", function () {
                  tooltip.style("display", "none");
                  d3.select(this).attr("fill", d => {
                    const stateName = stateIdToName[d.id];
                    const value = data[stateName]?.[metric];
                    return value ? colorScale(value) : "#ccc";
                  });
                });
            };

            const updateLegend = (colorScale, metric) => {
              const legendWidth = 300, legendHeight = 10;

              const legend = d3.select("#legend").html("").append("svg")
                .attr("width", legendWidth + 40)
                .attr("height", 80);

              const gradient = legend.append("defs").append("linearGradient")
                .attr("id", "legendGradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "0%");

              const scaleExtent = colorScale.domain();
              const step = (scaleExtent[1] - scaleExtent[0]) / 9;

              d3.range(9).forEach((d, i) => {
                gradient.append("stop")
                  .attr("offset", `${(i / 8) * 100}%`)
                  .attr("stop-color", colorScale(scaleExtent[0] + i * step));
              });

              legend.append("rect")
                .attr("x", 10)
                .attr("y", 10)
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .style("fill", "url(#legendGradient)");

              const legendScale = d3.scaleLinear()
                .domain(scaleExtent)
                .range([10, legendWidth + 10]);

              const axis = d3.axisBottom(legendScale)
                .ticks(5)
                .tickFormat(d3.format(".2s"));

              legend.append("g")
                .attr("transform", "translate(0, 30)")
                .call(axis);

              legend.append("text")
                .attr("x", legendWidth / 2)
                .attr("y", 70)
                .attr("text-anchor", "middle")
                .style("fill", "black")
                .style("font-size", "14px")
                .text(`Color Scale For ${metricLabels[metric]}`);
            };

            d3.select("#metric").on("change", function () {
              updateMap(this.value);
            });

            updateMap("personalIncome");
          });
        });
      });
    });
  </script>

</body>

</html>